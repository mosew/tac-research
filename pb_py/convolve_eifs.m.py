# Autogenerated with SMOP 0.32-7-gcce8558
from smop.core import *
# 

    
@function
def convolve_eifs(eifs=None,theta=None,P=None,n=None,tau=None,*args,**kwargs):
    varargin = convolve_eifs.varargin
    nargin = convolve_eifs.nargin

    # INPUTS:
    # eifs is a cell array of P eigenfunctions
    # theta is a parameter vector
    # P is # of eigenfunctions
    # tau is timestep = 5
    
    # OUTPUTS:
    # convolved_eifs is a P x n array of our eigenfunctions passed to the functional L, i.e. 
    #           convolved_sampled_eifs(i,j) = L_i(theta,phi_j)
    
    
    # Note: right now this doesn't do anything with the sampled
    # eigenfunctions.
    
    convolved_eifs=zeros(P,n)
# pillonetto_bell/src/convolve_eifs.m:16
    for i in arange(1,n).reshape(-1):
        for j in arange(1,P).reshape(-1):
            e_j=zeros(1,P)
# pillonetto_bell/src/convolve_eifs.m:19
            e_j[j]=1
# pillonetto_bell/src/convolve_eifs.m:20
            convolved_eifs[j,i]=L_i(theta,e_j,i,tau)
# pillonetto_bell/src/convolve_eifs.m:21
    
    return convolved_eifs
    
if __name__ == '__main__':
    pass
    