# Autogenerated with SMOP 0.32-7-gcce8558
from smop.core import *
# 

    
@function
def d2logpy_th(y=None,theta=None,tau=None,P=None,T=None,n=None,eivs=None,rkhs_eigenfile=None,data_path=None,*args,**kwargs):
    varargin = d2logpy_th.varargin
    nargin = d2logpy_th.nargin

    
    # INPUT:
    # y_total is m x n
    # OUTPUT:
    # nTheta x nTheta, where d2logpy_th(s,r) is
    
    # d (log( p(y|th) ) / d(th_s) d(th_r)
    
    
    nTheta=length(theta)
# pillonetto_bell/src/d2logpy_th.m:11
    Lmatrix_=Lmatrix(theta,P,T,rkhs_eigenfile,n,tau)
# pillonetto_bell/src/d2logpy_th.m:13
    dLmatrix_=dLmatrix(theta,P,n,Lmatrix_)
# pillonetto_bell/src/d2logpy_th.m:14
    assert_(size(y,1) == 1)
    s2=d2Vy_th(theta,P,T,n,eivs,Lmatrix_,dLmatrix_)
# pillonetto_bell/src/d2logpy_th.m:19
    s1=dVy_th(theta,P,T,n,eivs,Lmatrix_)
# pillonetto_bell/src/d2logpy_th.m:20
    s0=Vy_th(theta,P,T,n,tau,rkhs_eigenfile,data_path)
# pillonetto_bell/src/d2logpy_th.m:21
    d2logpy_th=zeros(nTheta,nTheta)
# pillonetto_bell/src/d2logpy_th.m:23
    for s in arange(1,nTheta).reshape(-1):
        for r in arange(1,nTheta).reshape(-1):
            d2logpy_th[s,r]=dot(- 0.5,(trace(numpy.linalg.solve(s0,(s2[:,:,s,r]))) - trace(dot(numpy.linalg.solve(s0,(s1[:,:,s] / s0)),s1[:,:,r])) + dot(dot(y,(numpy.linalg.solve(s0,(dot(s1[:,:,s] / s0,s1[:,:,r]) - s2[:,:,s,r] + dot(s1[:,:,r] / s0,s1[:,:,s]))) / s0)),y.T)))
# pillonetto_bell/src/d2logpy_th.m:27
    
    
    return d2logpy_th
    
if __name__ == '__main__':
    pass
    