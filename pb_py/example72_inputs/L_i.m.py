# Autogenerated with SMOP 0.32-7-gcce8558
from smop.core import *
# 

    
@function
def L_i(theta=None,f=None,i=None,tau=None,*args,**kwargs):
    varargin = L_i.varargin
    nargin = L_i.nargin

    # INPUTS:
    # i is the desired index of the output
    # theta is a vector of parameters
    # f is the input function handle
    # tau is the timestep
    
    # OUTPUTS:
    # output is a single number: it's the i^th output of our system applied to f
    
    # FOR EXAMPLE 7.2 OF PILLONETTO-BELL
    
    if logical_not(isnumeric(f)):
        g=lambda s=None: exp(dot(- theta[2],s))
# pillonetto_bell/src/example72_inputs/L_i.m:15
        fxg=lambda s=None: multiply(feval(f,s),feval(g,dot(i,tau) - s))
# pillonetto_bell/src/example72_inputs/L_i.m:16
        output=integral(fxg,0,dot(i,tau))
# pillonetto_bell/src/example72_inputs/L_i.m:17
    else:
        # if f is a numeric vector, it's encoding amplitudes of kernel eigenfunctions
        # In the below, it's assumed that T=1
        P=length(f)
# pillonetto_bell/src/example72_inputs/L_i.m:22
        w=dot(pi / 2,(dot(2,(arange(1,P))) - 1))
# pillonetto_bell/src/example72_inputs/L_i.m:23
        output=sum(multiply(multiply(f,sqrt(2)) / (theta[2] ** 2 + w ** 2),(dot(theta[2],sin(dot(dot(w,i),tau))) - multiply(w,(cos(dot(dot(w,i),tau)))) + multiply(w,(exp(dot(dot(- theta[2],i),tau)))))))
# pillonetto_bell/src/example72_inputs/L_i.m:24
    
    
    return output
    
if __name__ == '__main__':
    pass
    